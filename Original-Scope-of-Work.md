Below is a formal engineering specification for a complete 1:1 porting of [Stwo](https://github.com/starkware-libs/stwo) from Rust to Zig, targeting a functionally equivalent prover/verifier framework with comparable performance characteristics and a clear path to production-hardening.

Citations reference Stwo’s repo + official docs describing structure/benchmarks and its “work in progress” status.  ￼

⸻

1. Overview

1.1 Purpose

Implement a Zig-native port of the Stwo Circle STARK (CSTARK) prover+verifier framework currently written in Rust, preserving:
	•	Cryptographic correctness (bit/field exactness)
	•	Proof format compatibility goals (as defined in §3.5)
	•	Performance-critical design (SIMD-optimized hot paths)
	•	Extensibility for AIR / constraint systems

Stwo is a Rust workspace with multiple crates (core, constraint framework, AIR utilities, examples, std shims).  ￼

1.2 Scope

In-scope modules:
	•	Finite field arithmetic + extension fields used by Stwo
	•	Polynomial arithmetic + FFT/NTT (where applicable)
	•	Merkleization + hash (Poseidon2 benchmark scripts exist in repo)  ￼
	•	FRI + commitment scheme(s)
	•	Constraint framework / AIR evaluation engine
	•	Transcript / Fiat–Shamir
	•	Proof serialization/deserialization
	•	Verifier (including no_std-friendly profile equivalent)  ￼
	•	Examples ported to validate end-to-end flows

Out-of-scope (initially):
	•	Porting stwo-cairo (separate production-oriented prover on top of Stwo) beyond integration hooks.  ￼
	•	GPU acceleration (may be future workstream)
	•	Distributed proving / networking

1.3 Key Constraints
	•	Stwo is explicitly “Work in Progress” upstream; the Zig port must track an upstream revision/tag and define upgrade policy.  ￼
	•	Rust implementation emphasizes optimized SIMD operations; Zig port must provide an equivalent SIMD strategy.  ￼

⸻

2. Goals and Success Criteria

2.1 Functional Goals

G1. Prover: Generate valid proofs for all ported examples.
G2. Verifier: Verify proofs produced by the Zig prover (self-compatibility).
G3. Interoperability target (optional but recommended): Ability to verify proofs generated by upstream Rust Stwo for the same pinned revision, or document why not (proof format drift, transcript differences, field packing differences).
G4. Provide a stable Zig API for building applications (equivalent to Rust “framework” stance).  ￼

2.2 Non-Functional Goals

N1. Performance: Within 1.5× of Rust baseline for the Poseidon2 proof benchmark on the same machine/threads, and within 1.2× after SIMD + allocator tuning (target). (Benchmark harness parity required.)  ￼
N2. Determinism: Bit-for-bit reproducible proofs under fixed randomness/transcript inputs.
N3. Safety: Memory-safe-by-construction style in Zig (no unchecked pointer arithmetic in non-hot paths; hot paths carefully audited).
N4. Portability: Tier-1 support: macOS ARM64 (Apple Silicon) + Linux x86_64.
N5. no_std-equivalent profile: A “freestanding/minimal” build that matches the intent of std-shims and verifier restrictions.  ￼

2.3 Definition of Done
	•	All modules in §4 implemented with unit tests + property tests.
	•	End-to-end prover/verifier tests pass for all examples.
	•	Benchmark suite runs in CI and produces report artifacts (mirroring upstream’s benchmark emphasis).  ￼
	•	Security review checklist completed (§10).

⸻

3. Target Architecture

3.1 Repository Layout (Zig)

Single monorepo stwo-zig/:
	•	build.zig / build.zig.zon
	•	src/
	•	core/ (field, poly, transcript, utils)
	•	crypto/ (hash, merkle, commitments)
	•	fri/
	•	air/ (AIR structs + evaluation engine)
	•	constraints/ (constraint DSL + evaluator)
	•	proof/ (proof types, serialization)
	•	prover/
	•	verifier/
	•	examples/
	•	tests/
	•	unit/
	•	property/
	•	vectors/
	•	bench/
	•	scripts/ (benchmark runners, parity scripts)
	•	third_party/ (vendored minimal deps if needed)

3.2 Module Mapping to Rust Workspace

Rust Stwo describes these main crates: crates/stwo, crates/constraint-framework, crates/air-utils, crates/air-utils-derive, crates/examples, crates/std-shims.  ￼
Zig port MUST preserve that separation as module boundaries even if built as one Zig package, to keep reviewable parity.

3.3 Public API Shape (Zig)

Expose a small stable surface:
	•	stwo.Prover
	•	init(allocator, params)
	•	prove(air, trace, public_inputs) -> Proof
	•	stwo.Verifier
	•	verify(air, proof, public_inputs) -> bool
	•	air.Air trait-like interface (Zig struct with function pointers or comptime generics)
	•	constraints.ConstraintSystem

3.4 Build Profiles
	•	-Doptimize=ReleaseFast default for benchmarks
	•	-Dtarget= cross builds
	•	-Dfreestanding=true (verifier-only minimal build)
	•	-Dsimd=native|portable flag controlling vectorization strategy

3.5 Proof Format Compatibility Policy

Pick one (must be explicit in project README):
	•	Mode A (Recommended initially): “Zig-native proof format”
Guarantees self-compatibility; interop later.
	•	Mode B: “Rust-compatible proof format for pinned revision”
Requires strict replication of transcript, endianness, field packing, Merkle layout, and serialization schema.

If Mode B: add a compat/ test suite that pulls Rust-generated golden proofs for the pinned commit and verifies them in Zig.

⸻

4. Work Breakdown Structure (WBS)

4.1 Foundations (Week 0 Milestone)
	•	Pin upstream reference: tag or commit hash (record in UPSTREAM.md).
	•	Document algorithms + invariants to port.
	•	Implement baseline Zig project scaffolding, CI, formatting, lint rules.

4.2 Field Arithmetic

Deliverables:
	•	Base field element type(s) used by Stwo (likely small field emphasis per S-two positioning)  ￼
	•	Extension field(s) if used
	•	Constant-time-ish primitives where required
	•	SIMD-enabled batch ops (add/mul/square) and conversions

Tests:
	•	Algebraic laws
	•	Cross-check against Rust for random vectors (if interop harness enabled)

4.3 Hash + Merkle

Deliverables:
	•	Poseidon2 (required to run the Poseidon benchmark scripts conceptually)  ￼
	•	Merkle tree builder/verifier
	•	Domain separation + transcript absorption rules

Tests:
	•	Hash test vectors (from Rust or published vectors if exist)
	•	Merkle inclusion and root stability tests

4.4 Polynomial + FFT/NTT

Deliverables:
	•	Polynomial representation, evaluation, interpolation
	•	FFT/NTT implementation choices:
	•	portable scalar
	•	SIMD-accelerated butterfly kernels

Tests:
	•	Round-trip interpolate/evaluate
	•	Random consistency vs Rust

4.5 Constraint Framework + AIR

Deliverables:
	•	Constraint expression graph / DSL (Zig equivalent of constraint-framework)
	•	AIR utilities for trace handling and constraint evaluation (equivalent of air-utils)
	•	Efficient batch evaluation engine (vectorized)

Tests:
	•	Constraint satisfaction checks
	•	Minimal “Hello World AIR” example parity with official learning material expectations  ￼

4.6 Commitments + FRI

Deliverables:
	•	FRI folding layers + query sampling
	•	Commitment scheme used by Stwo (Merkle commitments over evaluation oracles)
	•	Soundness parameter plumbing

Tests:
	•	FRI consistency tests
	•	End-to-end proof generation for a small AIR

4.7 Prover Pipeline

Deliverables:
	•	Trace → commitments → composition polynomial → FRI → proof object
	•	Multi-threading strategy (optional early; required for perf parity later)

Tests:
	•	Deterministic proofs under fixed randomness
	•	Proof size sanity checks

4.8 Verifier Pipeline

Deliverables:
	•	Proof parsing + transcript recreation
	•	Query verification + constraints verification
	•	“freestanding verifier build” configuration

Tests:
	•	Reject invalid proofs (mutation tests)
	•	Cross-verification (if Mode B)

4.9 Examples + CLI

Deliverables:
	•	Port crates/examples equivalents (at least Poseidon-related example given benchmark scripts existence)  ￼
	•	Optional stwo-zig CLI:
	•	prove <example>
	•	verify <proof>

4.10 Benchmarks + Reporting

Deliverables:
	•	Zig benchmark harness mirroring upstream “quick benchmark” idea and cargo bench equivalents.  ￼
	•	Output JSON + markdown summary in CI artifacts.

⸻

5. Performance Engineering Requirements

5.1 Hot Path Identification (Mandatory)

Instrument:
	•	Field mul/add batches
	•	FFT kernels
	•	Hash permutation
	•	Merkleization
	•	FRI fold

Must produce a perf_report.md per release comparing:
	•	Rust baseline (pinned commit)
	•	Zig scalar
	•	Zig SIMD
	•	Zig SIMD + tuned allocator

5.2 SIMD Strategy
	•	Use Zig @Vector for portable SIMD where possible.
	•	Provide architecture-specific fast paths:
	•	ARM64 NEON
	•	x86_64 AVX2 (optional initially)
	•	Must maintain identical results across scalar/SIMD paths.

5.3 Memory + Allocator Strategy
	•	Use arena allocators for short-lived prover phases.
	•	Use explicit buffer reuse to match Rust’s performance intent (avoid churn).
	•	Zero-copy where safe.

⸻

6. Correctness & Testing Strategy

6.1 Test Levels
	•	Unit tests per module (field, hash, FFT, Merkle, FRI).
	•	Property tests (randomized algebraic identities).
	•	Golden vectors:
	•	Hash vectors
	•	Merkle root vectors
	•	Full proof vectors (if Mode B)

6.2 Differential Testing Against Rust (Strongly Recommended)

A parity/ harness that:
	•	Runs Rust Stwo pinned build to emit JSON/binary vectors
	•	Runs Zig to compare:
	•	intermediate states (optional)
	•	final proof fields (required if Mode B)
	•	verifier decision (required either way)

⸻

7. Security Requirements

7.1 Side-Channel & Constant-Time
	•	Field operations should avoid secret-dependent branches where feasible.
	•	Transcript / sampling must be deterministic and auditable.
	•	No use of unsafe pointer arithmetic except within documented, benchmark-validated hot kernels.

7.2 Input Validation

Verifier must:
	•	Validate proof length/structure before allocation
	•	Reject malformed encodings
	•	Enforce parameter bounds (soundness params, domain sizes)

7.3 Fuzzing
	•	Add fuzz targets for proof parser + verifier entrypoint.
	•	Mutation-based tests for rejecting near-valid proofs.

⸻

8. CI/CD Requirements

CI must run on:
	•	Linux x86_64
	•	macOS ARM64

Pipelines:
	•	zig fmt + lint
	•	unit + property tests
	•	parity tests (if enabled)
	•	benchmarks (nightly/weekly)
	•	sanitizer builds (ASan/UBSan equivalents where supported)

⸻

9. Documentation Requirements
	•	README.md: goals, build, run, benchmark
	•	UPSTREAM.md: pinned rust commit, update policy
	•	ARCHITECTURE.md: pipeline diagrams, module boundaries
	•	SECURITY.md: threat model, audit checklist
	•	COMPATIBILITY.md: Mode A vs Mode B status

⸻

10. Milestone Plan (Deliverable-Oriented)

M0. Scaffolding + upstream pin + CI green
M1. Field + hash + Merkle complete with vectors
M2. Poly/FFT complete, parity vs Rust for primitives
M3. Constraint/AIR engine runs “Hello World” style AIR
M4. FRI + commitments complete, small proof works
M5. Full prover/verifier for examples, deterministic proofs
M6. Bench parity + SIMD optimization pass
M7. Verifier freestanding profile + fuzzing

⸻

11. Risks & Mitigations
	•	Upstream churn (Stwo WIP): mitigate by pinning and only upgrading on explicit sprints.  ￼
	•	SIMD correctness: require scalar reference + exhaustive randomized differential tests.
	•	Proof-format mismatch: adopt Mode A first; Mode B only after stable internal pipeline.

⸻

12. Acceptance Checklist

To accept the Zig port:
	•	✅ All examples prove+verify in Zig
	•	✅ Verifier rejects mutated proofs (≥20 mutation cases)
	•	✅ Benchmarks run and meet N1 targets on macOS ARM64
	•	✅ Parity harness exists (even if Mode A only compares verifier decisions)
	•	✅ Documentation complete

⸻

If you want, I can also produce a concrete “port order” map (file-by-file) once we inspect the exact Rust module tree under crates/stwo and identify the hot kernels (field/FFT/hash/FRI) that must be lifted first.